<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Support Vector Machine</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <link href="assets/bootstrap/css/bootstrap.css" rel="stylesheet">
    <link href="assets/custom/custom.css" rel="stylesheet">
    <!-- font-awesome -->
    <link href="assets/font-awesome/css/font-awesome.min.css" rel="stylesheet">

    <!-- prism -->
    <link href="assets/prism/prism.css" rel="stylesheet">
    <link href="assets/prism/prism.r.css" rel="stylesheet">
    <script type='text/javascript' src='assets/prism/prism.js'></script>
    <script type='text/javascript' src='assets/prism/prism.r.js'></script>
    
    
    
    <script type="text/javascript" src="assets/MathJax/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
   MathJax.Hub.Config({    
     extensions: ["tex2jax.js"],    
     "HTML-CSS": { scale: 100}    
   });
   </script>
    
    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="js/html5shiv.js"></script>
    <![endif]-->
    
    <link href='http://fonts.googleapis.com/css?family=Lato' rel='stylesheet' type='text/css'>
    <!-- <link href='http://fonts.googleapis.com/css?family=Lustria' rel='stylesheet' type='text/css'> -->
    <link href='http://fonts.googleapis.com/css?family=Bitter' rel='stylesheet' type='text/css'>
    

    <!-- Fav and touch icons -->
    <link rel="apple-touch-icon-precomposed" sizes="144x144" href="ico/apple-touch-icon-144-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="114x114" href="ico/apple-touch-icon-114-precomposed.png">
      <link rel="apple-touch-icon-precomposed" sizes="72x72" href="ico/apple-touch-icon-72-precomposed.png">
                    <link rel="apple-touch-icon-precomposed" href="ico/apple-touch-icon-57-precomposed.png">
                                   <!-- <link rel="shortcut icon" href="ico/favicon.png"> -->
  </head>

  <body>

    <div class="container-narrow">

      <div class="masthead">
        <ul class="nav nav-pills pull-right">
           
        </ul>
        <p class="myHeader">Support Vector Machine</p>
      </div>

      <hr>

<div class="container-fluid">
   <div class="row-fluid">
   
   <div class="col-md-3 well">
   <ul class = "nav nav-list" id="toc">
   <li class='nav-header unselectable' data-edit-href='01.intro.Rmd'>Defination</li>
      
      <li class='active'>
         <a target='_self' class='nav-not-header' href='#in-short'>In Short</a>
      </li>


      <li class='active'>
         <a target='_self' class='nav-not-header' href='#motivation'>Motivation</a>
      </li>


<li class='nav-header unselectable' data-edit-href='01.intro.Rmd'>Details</li>
      
      <li class='active'>
         <a target='_self' class='nav-not-header' href='#more-about-svm'>More about SVM</a>
      </li>


      <li class='active'>
         <a target='_self' class='nav-not-header' href='#distance-from-point-to-a-plane'>Distance from Point to A Plane</a>
      </li>


      <li class='active'>
         <a target='_self' class='nav-not-header' href='#functional-and-geometric-margins'>Functional and Geometric Margins</a>
      </li>


      <li class='active'>
         <a target='_self' class='nav-not-header' href='#primal-optimization'>Primal Optimization</a>
      </li>


      <li class='active'>
         <a target='_self' class='nav-not-header' href='#dual-optimization'>Dual Optimization</a>
      </li>


      <li class='active'>
         <a target='_self' class='nav-not-header' href='#kernel'>Kernel</a>
      </li>


<li class='nav-header unselectable' data-edit-href='01.intro.Rmd'>Non-linearly Separable</li>
      
      <li class='active'>
         <a target='_self' class='nav-not-header' href='#slack-variables'>"Slack" Variables</a>
      </li>


      <li class='active'>
         <a target='_self' class='nav-not-header' href='#regularization'>Regularization</a>
      </li>


<li class='nav-header unselectable' data-edit-href='01.intro.Rmd'>Algorithm</li>
      
   </ul>
   </div>

<div class="col-md-9 tab-content" id="main-content">

<div class='tab-pane active' id='in-short'>
<h3>In Short</h3>

<h4>What is SVM</h4>

<p>A support vector machine constructs a <strong>hyperplane or set of hyperplanes in a high- or infinite-dimensional space</strong>, 
which can be used for classification, regression, or other tasks.</p>

<h4>Why is SVM</h4>

<p>Original classification problem may be stated in a finite dimensional space, it often happens that 
the sets to discriminate are not linearly separable in that space. For this reason, it was proposed 
that the original finite-dimensional space be mapped into a much higher-dimensional space, presumably
making the separation easier in that space.</p>

<p>The mappings used by SVM schemes are designed to ensure that dot products may be computed easily in 
terms of the variables in the original space, by defining them in terms of a kernel function \(k(x,y)\) 
selected to suit the problem.</p>

<h4>What is optimal</h4>

<p>A good separation is achieved by the hyperplane that has the largest distance to the nearest training 
data point of any class (so-called functional margin), since in general the larger the margin the lower 
the generalization error of the classifier.</p>

</div>


<div class='tab-pane' id='motivation'>
<h3>Motivation</h3>

<p>In the case of support vector machines, a data point is viewed as a p-dimensional vector (a list of 
p numbers), and we want to know whether we can separate such points with a (p âˆ’ 1)-dimensional 
hyperplane. This is called a linear classifier. </p>

<p>There are many hyperplanes that might classify the data. One reasonable choice as the best hyperplane 
is the one that represents the largest separation, or margin, between the two classes. So we choose 
the hyperplane so that the distance from it to the nearest data point on each side is maximized. If 
such a hyperplane exists, it is known as the maximum-margin hyperplane and the linear classifier it 
defines is known as a maximum margin classifier; or equivalently, the perception of optimal stability.</p>

<p>Any hyperplane can be written as the set of points \(\mathbf{x}\) satisfying</p>

<p>\(\mathbf{w}\cdot\mathbf{x} - b = 0\)</p>

</div>


<div class='tab-pane' id='more-about-svm'>
<h3>More about SVM</h3>

<p>An SVM model is a representation of the examples as points in space, mapped so that the examples of
the separate categories are divided by a clear gap that is as wide as possible. New examples are 
then mapped into that same space and predicted to belong to a category based on which side of the 
gap they fall on.</p>

<p>It often happens that the sets to discriminate are not linearly separable in that space. For this 
reason, it was proposed that the original finite-dimensional space be mapped into a much 
higher-dimensional space, presumably making the separation easier in that space.</p>

<p>The hyperplanes in the higher-dimensional space are defined as the set of points whose dot product
with a vector in that space is constant.</p>

</div>


<div class='tab-pane' id='distance-from-point-to-a-plane'>
<h3>Distance from Point to A Plane</h3>

<p>First of all, we have to recall that one plane in Euclidean Space can be expressed as:
\[
\omega^Tx + b = 0, \;\;\;\; x \in R^d
\]
Here \(\omega\) is the <strong>normal</strong> of the hyperplane. For any point \(x_i\) that is on this hyperplane, 
it should have \(\omega^Tx_i + b = 0\).</p>

<p>Then a common question is how to calculate the distance from a point outside of plane to this hyperplane.
Suppose the point is \(x_0 \in R^d\), and we also can randomly find another point \(x_1 \in R^d\) that is on the 
hyperplane. Then we have a vector \(x_0 - x_1\), and the distance between \(x_0\) and the plane is nothing but
the norm of the projection of vector \(x_0 - x_1\) to the <strong>normal</strong> of the plane (\(\omega\)). And we know that
the projection is just the inner product of two vectors.
\[
Dist = \|Proj_{\omega}(x_0 - x_1)\| = \frac{\|\omega^T(x_0 - x_1)\|}{\|\omega\|} = \frac{\|\omega^Tx_0 + b\|}{\|\omega\|}
\]</p>

</div>


<div class='tab-pane' id='functional-and-geometric-margins'>
<h3>Functional and Geometric Margins</h3>

<p>The geometric margin is just a scaled version of the functional margin.</p>

<p>You can think the functional margin, just as a testing function that will tell you whether a particular 
point is properly classified or not. And the geometric margin is functional margin scaled by \(\|\omega\|\)</p>

<p>the result would be positive for properly classified points and negative otherwise. If you scale 
that by \(\|\omega\|\) then you will have the geometric margin. </p>

<p>Why does the geometric margin exists?</p>

<p>Well to maximize the margin you need more that just the sign, you need to have a notion of magnitude,
the functional margin would give you a number but without a reference you can&#39;t tell if the point is 
actually far away or close to the decision plane. The geometric margin is telling you not only if 
the point is properly classified or not, but the magnitude of that distance in term of units of 
\(\|\omega\|\) </p>

</div>


<div class='tab-pane' id='primal-optimization'>
<h3>Primal Optimization</h3>

<p>First of all, consider a problem of the following form:</p>

<p>\[
\begin{aligned}
\min_{\omega} & f(\omega) \\
s.t. & h_i(\omega) = 0, \;\;\; i = 1, \cdots, l 
\end{aligned}
\]</p>

<p>It is obvious that the method of Lagrange multipliers can be used to solve it. In this method, we
define the <strong>Lagrangian</strong> to be
\[
\mathcal{L}(\omega, \beta) = f(\omega) + \sum_{i=1}^{l}\beta_ih_i(\omega)
\]
Here the \(\beta\)&#39;s are called the <strong>Lagrangian multipliers</strong>. We would then find and set \(\mathcal{L}\)&#39;s
partial derivatives to zero:
\[
\frac{\partial\mathcal{L}}{\partial\omega_i} = 0; \;\;\; \frac{\partial\mathcal{L}}{\partial\beta_i} = 0
\]
and solve for \(\omega\) and \(\beta\), since the second derivative will give us \(h_i(\omega) = 0\)</p>

<p>But sometimes, the constraint are not just \(h_i(\omega) = 0\). We may have inequality and equality constraints.
So the problem will become as following, which we call the <strong>primal</strong> optimization problem:
\[
\begin{aligned}
\min_{\omega} & f(\omega) \\
s.t. & g_i(\omega) \le 0, \;\;\; i = 1, \cdots, k \\
& h_i(\omega) = 0, \;\;\; i = 1, \cdots, l 
\end{aligned}
\]
To solve it, we start by defining the <strong>generalized Lagrangian</strong>
\[
\mathcal{L}(\omega, \beta) = f(\omega) + \sum_{i=1}^{k}\alpha_ig_i(\omega) + \sum_{i=1}^{l}\beta_ih_i(\omega)
\]
Here, \(\alpha_i\) and \(\beta_i\) are Lagrange multipliers. And for the multipliers associated with inequality,
we should have further constraint: \(\alpha_i \ge 0\). Consider the quantity:
\[
\theta_{\mathcal{P}}(\omega) = \max_{\alpha, \beta: \alpha_i \ge 0} \mathcal{L}(\omega, \alpha, \beta)
\]
Here, the &quot;\(\mathcal{P}\)&quot; subscript stands for &quot;primal&quot;. For this quantity, we fix the \(\omega\), and vary 
\(\alpha\) and \(\beta\). If the given \(omega\) violates any primal constraints for some \(i\), the we will have 
\[
\theta_{\mathcal{P}}(\omega) = f(\omega) + \max_{\alpha} \sum_{i=1}^{k}\alpha_ig_i(\omega) + \max_{\beta} 
\sum_{i=1}^{l}\beta_ih_i(\omega) =  \infty
\]</p>

</div>


<div class='tab-pane' id='dual-optimization'>
<h3>Dual Optimization</h3>

</div>


<div class='tab-pane' id='kernel'>
<h3>Kernel</h3>

<p>Kernel methods owe their name to the use of kernel functions, which enable them to operate in a 
high-dimensional, implicit feature space without ever computing the coordinates of the data in that 
space, but rather by simply computing the inner products between the images of all pairs of data in the
feature space. This operation is often computationally cheaper than the explicit computation of the 
coordinates. This approach is called the &quot;kernel trick&quot;. </p>

</div>


<div class='tab-pane' id='slack-variables'>
<h3>&quot;Slack&quot; Variables</h3>

<p>Previously, we introduced how to separate points by linearly separable hyperplane. But it is possible
that the large margin solution is better even though one constraint is violated.</p>

<p>So we permit to have functional margin less than 1 for some cases, such that 
\[y_i(\omega^Tx_i + b) \ge 1 - \xi_i\]
\[\xi_i \ge 0\] 
This \(\xi_i\) are called slack variables. For the support vectors, the functional 
margin is 
\[\gamma_i = y_i(\omega^Tx_i + b) = 1,\] 
which means \(\xi_i = 0\), and distance from support vectors to classification hyperplane is \(\frac{1}{\|\omega\|}\).
Originally, within either class, distance from any point to the classification hyperplane is larger or equal to 
the \(\frac{1}{\|\omega\|}\). But now since we permit have some cases that functional margin is less than 1, we will
have some cases that the distance from those points to the classification hyperplane are less than 1 or maybe 
even larger than 1 but on the other side. So in other words, there are two different situations for slack variable.</p>

<h4>Margin violation</h4>

<p>For this type of situation, we have <strong>\(0 < \xi_i \le 1\)</strong>. This means the distance between this type of points
and the hyperplane \(\omega^Tx + b\) is:
\[ 0 \le \frac{1 - \xi_i}{\|\omega\|} < \frac{1}{\|\omega\|}\]
The above distance greater or equal to zero means this point is still on the correct side of classification 
hyperplane. On the other hand, it should smaller than \(\frac{1}{\|\omega\|}\), which is the distance from 
support vector.</p>

<p>In summary, margin violation means we will permit a correct classification point but with smaller margin than
support vectors. One thing to keep in mind that the distance we are talking about here do not have a direction.
Which means we are talking about the distance for a point from a given class to the hyperplane. Later on we 
will see a negative distance, that means the distance is from the other side.</p>

<h4>Misclassified</h4>

<p>For this type of situation, we have <strong>\(\xi_i > 1\)</strong>. This means the distance between this type of points and the
hyperplane \(\omega^Tx + b\) is:
\[
\frac{1 - \xi_i}{\|\omega\|} < - \frac{1}{\|\omega\|}
\]
The magnitude of this distance is actually greater than \(\frac{1}{\|\omega\|}\), which is because the distance
is larger than the support vectors. However the negative sign with the distance means this point is misclassified
on the other side.</p>

</div>


<div class='tab-pane' id='regularization'>
<h3>Regularization</h3>

<p>Since we permit margin violation or misclassified points in our sample, we should add penalty on those points.
One thing should be noticed that if the \(\xi_i\) is sufficiently large, then constraint for every point can be
satisfied.</p>

<p>\[ 
\begin{aligned}
& \min_{\gamma, \omega, b} \frac{1}{2}||\omega||^2 + C\sum_{i=1}^{m} \xi_i \\
s.t. & y_i(\omega^Tx_i + b) \ge 1 - \xi_i \\
& \xi_i \ge 0
\end{aligned}
\]</p>

<p>C is the regularization parameter, </p>

<ul>
<li>If C is small, then all constraints are easily to be ignored. It means we can have relatively large \(\xi_i\)
and to have a large margin with many cases of margin violation and misclassification.</li>
<li>If C is large, then all constraints are hard to be ignored. It means we can have small \(\xi_i\) and to have a
narrow margin in order to avoid margin violation or misclassification.</li>
<li>If C is \(\infty\), then all constraints are enforced to be satisfied, which called hard margin. In this extreme
case, we do not have soft margin solution, and which goes back to original SVM.</li>
</ul>

<p>Then the optimization problem can be reformed using <strong>Lagrange multipliers</strong> method. Let us define 
the <strong>Lagrangian</strong> to be:</p>

<p>\[
\begin{aligned}
\mathcal{L}(\omega, b, \xi, \alpha, r) = \frac{1}{2}\omega^T\omega + C\sum_{i=1}^m\xi_i - 
\sum_{i=1}^m\alpha_i[y_i(x^Tx + b) - 1 + \xi_i] - \sum_{i=1}^mr_i\xi_i
\end{aligned}
\]</p>

<p>Here \(\alpha_i\) and \(r_i\) are our Lagrange multipliers.
All optimal solutions must satisfy Karush-Kuhn-Tucker (KKT) conditions:</p>

<p>\[
\begin{aligned}
\frac{\partial}{\partial \omega}\mathcal{L} = 0 \\
\frac{\partial}{\partial b}\mathcal{L} = \sum_{i=1}^m \alpha_i y_i = 0 \\
\frac{\partial}{\partial \xi_i}\mathcal{L} = C - \alpha_i - r_i = 0 & \;\;\; i = 1, 2, \cdots, m \\
\alpha_i[y_i(x^Tx + b) - 1 + \xi_i] = 0 & \;\;\; i = 1, 2, \cdots, m \\
r_i\xi_i = 0 & \;\;\; i = 1, 2, \cdots, m \\
\alpha_i \ge 0 & \;\;\; i = 1, 2, \cdots, m \\
r_i \ge 0 & \;\;\; i = 1, 2, \cdots, m \\
-\xi_i \le 0 & \;\;\; i = 1, 2, \cdots, m \\
-[y_i(x^Tx + b) - 1 + \xi_i] \le 0 & \;\;\; i = 1, 2, \cdots, m
\end{aligned}
\]</p>

<p>First we look at the third condition. It can be rewrote as \(\alpha_i = C - r_i\), recall that \(r_i \ge 0\).
So we can get the condition for \(\alpha_i\) as:
\[0 \le \alpha_i \le C\]</p>

<p>The optimality conditions are both necessary and sufficient. If we have
\(C\), \(\xi\), b, \(\alpha\), and r satisfying the above conditions, we know that they represent optimal 
solutions to the primal and dual problems.</p>

<p>Also among all conditions, the KKT dual-complementarity conditions are:
\[
\begin{aligned}
\alpha_i[y_i(x^Tx + b) - 1 + \xi_i] = 0 & \;\;\; i = 1, 2, \cdots, m \\
r_i\xi_i = 0 & \;\;\; i = 1, 2, \cdots, m \\
\end{aligned}
\]
Then, we can have </p>

<ul>
<li>If \(\alpha_i = 0\), then \(y_i(x^Tx + b) - 1 + \xi_i > 0\), according to the third condition of KKT
\(r_i = C \Rightarrow \xi_i = 0 \Rightarrow y_i(x^Tx + b) > 1\)</li>
<li>If \(\alpha_i = C\), then according to the third condition of KKT, \(r_i = 0 \Rightarrow \xi_i >0\), 
\(y_i(x^Tx + b) - 1 + \xi_i = 0 \Rightarrow y_i(x^Tx + b) < 1\)</li>
<li>If \(0 < \alpha_i < C\), then \(y_i(x^Tx + b) - 1 + \xi_i = 0\), and \(r_i \ne 0 \Rightarrow \xi_i = 0\).
So \(y_i(x^Tx + b) = 1\)</li>
</ul>

</div>

   
   <ul class="pager">
      <li><a href="#" id="previous">&larr; Previous</a></li> 
      <li><a href="#" id="next">Next &rarr;</a></li> 
   </ul>
</div>


</div>
</div>

<hr>

<div class="footer">
   <p>&copy; Xiaosu Tong, 2014</p>
</div>
</div> <!-- /container -->

<script src="assets/jquery/jquery.js"></script>
<script type='text/javascript' src='assets/custom/custom.js'></script>
<script src="assets/bootstrap/js/bootstrap.js"></script>
<script src="assets/custom/jquery.ba-hashchange.min.js"></script>
<script src="assets/custom/nav.js"></script>

</body>
</html>